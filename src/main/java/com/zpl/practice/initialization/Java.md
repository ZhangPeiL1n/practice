#Java

##继承
---
###构造方法
- 构造方法其实不负责实例的创建，只负责实例的初始化，在进行初始化的时候实例是已经创建好的（在内存中划分区域，在构造方法中使用`this`来指代创建好的实例），只不过构造方法返回的是初始化之后的实例，让人感觉构造方法是用来创建实例的
- 构造方法一般用`public`修饰，是为了在任何地方都可以去创建实例。但根据需求也可以设置成其他权限，比如只被子类访问就设置成`protected`，比如不希望随意创建本类实例就可以设置成`private`（单例模式）
###成员变量的初始化顺序
- 成员变量有两个初始化位置：
	1. 在声明时初始化
	2. 在构造函数中初始化
		- 非静态代码块执行在构造函数之前，可以理解为可复用的构造函数，所以非静态代码块中初始化其实和构造函数中初始化是一样的
- 声明时初始化发生的位置根据我测试的结果发生在`super()`方法执行之后，在父类构造方法执行完毕后，开始执行声明时初始化，然后才执行构造方法或非静态代码块中的内容
###继承
- 子类继承父类后，会获得父类的所有成员变量和方法（被`private`修饰的除外）
	- 若父类有一个`private`修饰的方法，在子类中写同名的方法不算做方法重写
- 如果子类中有与父类同名的实例变量，那么子类的实例变量会隐藏父类的实例变量
	- 如果在某个方法中访问名为`a`的成员变量，但没有显示指定调用者，则系统查找`a`的顺序为：
		1. 查找该方法中是否有名为`a`的局部变量
		2. 查找当前类中是否包含名为`a`的成员变量
		3. 查找当前类的父类中是否包含名为`a`的成员变量，依次上溯当前类的所有父类，直到`java.lang.Object`类，如果最终不能找到名为`a`的成员变量，则系统出现编译错误
	- 从上面的查找范围可以看出来范围是逐步扩大的，从当前方法的作用域扩大到当前类，再扩大到父类
	- 即子类有就使用子类的，子类没有使用父类的
		- 子类父类都有时，`this.xxx`表示子类实例变量（当方法中没有局部变量`xxx`时，也可以不写`this`，即不用区分局部变量和实例变量），`super.xxx`表示父类实例变量
		- 当子类没有父类中有时，`xxx`、`this.xxx`和`super.xxx`都是父类实例变量（若定义局部变量`xxx`，则`xxx`是局部变量值，`this.xxx`和`super.xxx`都是父类实例变量）
- 子类构造方法调用父类构造方法有以下几种情况：
		1. 子类构造方法第一行使用`super`显式的调用父类构造方法，根据`super`的参数决定调用对应的父类构造方法
		2. 子类构造方法第一行使用`this`显式的调用本类中重载的构造方法，根据`this`的参数决定调用对应的本类构造方法。调用本类另一构造方法时会调用父类构造方法
		3. 子类构造方法即没有`super`调用，也没有`this`调用，则在执行本构造方法之前，会隐式的调用父类的无参构造方法（即`super()`）

###访问控制符
- `private`是本类访问权限，只能本类访问
		- 修饰变量：只能被本类实例变量访问
		- 修饰方法：
- 默认权限`(default)`是包访问权限，不写访问控制符就是默认权限
- `protected`是在包访问权限基础上增加子类访问权限（子类有可能不在同一个包中）
- `public`是公共访问权限，即不同包也不是子类的类可以访问
- 子类重写父类方法，访问权限不能小于父类权限
###[`this`和`super`](https://www.cnblogs.com/hasse/p/5023392.html)
- `this`
	- 指向对象本身
	- 区分成员变量和局部变量（还有形参）
		- `this.xxx`指成员变量xxx
		- 不加this的变量指方法的局部变量或者方法的形参
	- 调用本类的其他构造方法，需显示写在构造方法第一行
- `super`
	- 指向父类对象
	- 区分子类和父类的成员变量和方法
		- `super.xxx`明确的指向父类的变量xxx
	- 子类中调用父类的构造方法，需在子类构造方法第一行写
###代码块
- 代码块分普通代码块和静态代码块
- 普通代码块用于初始化实例变量
	-  普通代码块和声明实例变量指定初始值的执行顺序取决于在类中的排列顺序，但是都在构造方法之前
- 静态代码块用于初始化静态变量
	- 静态代码块只会在类第一次加载的时候执行一次
- 执行顺序
	- 创建一个对象
	- 假设：子类继承父类，子类父类都有静态代码块，非静态代码块，无参构造方法
	- 第一次的情况（未加载类）：先加载父类，执行父类静态代码块，然后加载子类，执行子类静态代码块
	- 然后执行父类非静态代码块，父类构造方法	
	- 再执行子类非静态代码块，子类构造方法
	- 若已经加载过类，则只会执行上面两个步骤，不会执行父类和子类的静态代码块内容
	- 即**父类静态代码块内容 -> 子类静态代码块内容 -> 父类非静态代码块内容 -> 父类构造方法内容 -> 子类非静态代码块内容 -> 子类构造方法内容**



##不可变类`(Immutable)`
---
###不可变类
- 不可变类的意思是创建该类的实例后，该实例的成员变量是不可改变的
	- 可变类就是相对的，类实例创建后可以改变成员变量值
- Java提供的8个包装类和String类都是不可变类，当创建他们的实例后，其实例的实例变量不可改变
- 如何保证类的不可变性
	- 保证成员变量只能被赋值一次
		- 只在构造方法中进行赋值
		- 不可重新被赋值（`final`修饰，不提供setter方法）
	- 保证成员变量不会被外部修改
		- 在构造方法中赋值时使用深拷贝
		- 在`getter`中返回对象也使用深拷贝
		- 使用`private`修饰，外部不可见
	- 具体要求
		1. 使用`private`和`final`修饰符来修饰该类的成员变量
			- `private`保证变量不可被外部访问修改
			- `final`保证变量的值不可改变
		2. 不提供成员变量的修改方法，比如setter
			- 这个跟1应该是有冲突的，被`final`修饰的变量不能创建setter方法
		3. 通过构造器初始化所有成员变量，进行深拷贝
			- 保证不能通过修改参数变量来修改已初始化的成员变量
		4. 在getter方法中，不返回成员本身，而是返回成员的拷贝
			- 保证不把成员变量本身外泄出去，使得成员变量被修改
	
###`String`类是如何做到保证不可变的
###`final`关键字
- `final`修饰成员变量
	- 被`final`修饰的变量一旦获取初始值就不可被改变，`final`既可以修饰成员变量（包括类变量和实例变量），也可以修饰局部变量、形参
	- **`final`修饰的成员变量必须由程序员显式的指定初始值**
		- 类变量：必须在静态初始化块中指定初始值或声明该类变量时指定初始值，而且只能在两个地方其中之一指定
		- 实例变量：必须在非静态代码块、声明该实例变量或构造器中指定初始值，而且只能这三个地方其中之一指定
- `final`修饰基本类型变量和引用类型变量的区别
	- 当使用`final`修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变
	- 当使用`final`修饰引用类型时，`final`只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象可以改变
- `final`修饰方法
	- `final`修饰的方法不可被重写
		- 被`private`修饰的方法对子类不可见，所以`private final`一起修饰方法没有意义
		- 子类中写了一个跟父类中同名`private`的方法并不是重写
- `final`修饰类
	- `final`修饰的类不可以有子类

##内部类
---
- 内部类：将一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类，包含内部类的类也被称为外部类。
- 内部类的作用：
	- 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一包中的其他类访问该类。
	- **内部类成员可以直接访问外部类的私有数据**，因为内部类被当成其外部类成员，同一类的成员之间可以相互访问。但外部类不能访问内部类的实现细节，例如内部类的成员变量
	- 匿名内部类适合用于创建那些仅需要一次使用的类。
- 内部类与外部类的区别：
	- 内部类比外部类可以多使用三个修饰符：`private`、`protected`、`static`--外部类不可以使用这三个修饰符。
		- 外部类的上一级程序单元是包，所以它只有两个作用域：同一个包内和任何位置。因此只需要两种访问权限：包访问权限和公开访问权限，对应省略访问控制符和`public`访问控制符。而内部类的上一级程序单元是外部类，它就具有4个作用域：同一个类、同一个包、父子类和任何位置，因此可以使用4中访问控制权限
	- 非静态内部类不能拥有静态成员
		- zpl：普通类不能用`static`进行修饰
- 内部类种类：
	- 成员内部类：成员内部类是一种与成员变量、方法、构造器和初始化块相似的类成员，局部内部类和成员内部类则不是类成员
		- 非静态内部类
		- 静态内部类
	- 局部内部类
	- 匿名内部类
###非静态内部类
- 非静态内部类：没有使用`static`的内部类是非静态内部类
```java
//外部类
public class OuterClass {
    private String outerName;
    //外部类私有成员变量
    private int outerAge;
    //内部类
    public class InnerClass{
	    //内部类成员变量
        private String innerName;
        private void print(){
	        //内部类可以直接访问外部类私有成员变量
            System.out.println(outerAge);
        }
    }
}
```
- 上面代码中`InnerClass`是一个普通的类定义，但是因为把这个类定义放在了另一个类的内部，所以它就成了一个内部类，可以使用`private`修饰符来修饰这个类
- 编译上面程序，可以看到文件所在路径生成了两个class文件，一个是`Outer.class`另一个是`Outer$Inner.class`，前者是外部类`Outer`的class文件，后者是内部类`Inner`的class文件，即成员内部类（包括静态内部类、非静态内部类）的class文件总是这种形式：`OuterClass$InnerClass.class`
- 非静态内部类`(InnerClass)`可以直接访问外部类`(OuterClass)`的`private`成员`(outerAge)`
	- 这是因为在非静态内部类对象里，保存了一个它所寄生的外部类对象的引用（当调用非静态内部类的实例方法时，必须有一个非静态内部类实例，非静态内部类实例必须寄生在外部类实例里）
	- 当在非静态内部类的方法内访问某个变量时，系统优先在该方法内查找是否存在改名字的局部变量，如果存在就使用该变量；如果不存在，则找到该方法所在的内部类中查找是否存在该名字的成员变量，如果存在则使用该成员变量；如果不存在，则到该内部类所在的外部类中查找是否存在该名字的成员变量，如果存在则使用该成员变量；如果依然不存在，则编译错误
		- 即从作用域小向作用域大查
		- 如果外部类成员变量、内部类成员变量与内部类里方法的局部变量同名，则可通过使用this、外部类名类名.this作为限定来区分。
```
public class OuterClass {
    private String prop = "外部类的实例变量";
    public class InnerClass{
        private String prop = "内部类的实例变量";
        private void print(){
            String prop = "局部变量";
            //通过外部类类名.this.变量名 访问外部类实例变量
            System.out.println(OuterClass.this.prop);
            //通过this.变量名访问内部类实例变量
            System.out.println(this.prop);
            //直接访问局部变量
            System.out.println(prop);
        }
    }
}
```
- 非静态内部类的成员可以访问外部类的`private`成员，但是反过来就不成立了。非静态内部类的成员只在非静态内部类范围内是可知的，并不能被外部类直接使用。如果外部类需要访问非静态内部类的成员，必须显示创建非静态内部类对象来调用访问其势力成员。
	- 非静态内部类可以直接访问外部类成员，因为要使用非静态内部类，得现有非静态内部类实例，非静态内部类实例得先有外部类实例，所以非静态内部类可以直接使用外部类成员
	- 但是反过来说有外部类实例不一定会创建内部类实例，没有非静态内部类实例就没法直接调用非静态内部类的成员。所以就不一定能访问非静态内部类实例成员
```
public class OuterClass {
    private int outProp = 9;
    public class InnerClass{
        private int inProp = 5;
        private void print(){
            System.out.println(outProp);
        }
    }
    
    public void accessInnerProp(){
        //外部类不能直接访问非静态内部类的实例变量
        //下面代码出现编译错误
        //System.out.println(inProp);
        //如需访问内部类的实例变量，必须显式创建内部类对象
        System.out.println(new InnerClass().inProp);
    }

    public static void main(String[] args) {
        //执行下面代码，只创建了外部类对象，没有创建内部类对象
        OuterClass outerClass = new OuterClass();
        
        outerClass.accessInnerProp();
    }
}
```
- 根据静态成员不能访问非静态成员的规则，外部类的静态方法、静态代码块不能直接访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例等。不允许在外部类的静态成员中直接使用非静态内部类
- Java不允许在非静态内部类中定义静态成员
###静态内部类
- 静态内部类：使用`static`修饰的成员内部类是静态内部类
	- 使用`static`修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象
	- `static`关键字的作用是把类的成员变成类相关，而不是实例相关，即`static`修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可以使用`static`修饰；而内部类的上一级程序单元是外部类，使用`static`修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此`static`关键字不可修饰外部类，但可修饰内部类
	- 静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。**即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员**
	- Java允许在接口里定义内部类，接口里定义的内部类默认使用`public static`，也就是说，接口内部类只能是静态内部类。

##线程
---
###线程状态
- `NEW`
	 - `NEW`状态是线程实例化后从未执行`start()`方法的状态
- `RUNNABLE`
	 - `RUNNABLE`状态是线程进入运行的状态
- `TERMINATED`
	- `TERMINATED`状态是线程被销毁时的状态
- `TIMED_WAITING`
	- `TIMED_WAITING`代表线程执行了`Thread.sleep()`，呈等待状态，等待时间到达，继续向下运行
- `BLOCKED`
	- `BLOCKED`状态出现在某一个线程在等待锁的时候
- `WAITING`
		- `WAITING`状态是线程执行了`Object.wait()`方法后所处的状态


###线程组
